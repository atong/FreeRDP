/**
 * FreeRDP: A Remote Desktop Protocol Client
 * RemoteFX Codec Library Unit Tests
 *
 * Copyright 2011 Anthony Tong <atong@trustedcs.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The test data is from [MS-RDPNCS] 4, Protocol Examples.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <freerdp/types.h>
#include <freerdp/utils/print.h>
#include <freerdp/utils/memory.h>
#include <freerdp/utils/hexdump.h>
#include <freerdp/codec/nsc.h>

#include "test_nsc.h"

static const uint8 compressed_bitmap_data[] =
{
0x71, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
0x03, 0x01, 0x00, 0x00, 0x63, 0x63, 0x01, 0x64, 0x64, 0x00, 0x63, 0x63, 0x02, 0x64, 0x64, 0x00,
0x63, 0x63, 0x00, 0x64, 0x64, 0x01, 0x63, 0x63, 0x01, 0x64, 0x64, 0x01, 0x63, 0x63, 0x01, 0x64,
0x64, 0x00, 0x63, 0x63, 0x00, 0x64, 0x64, 0x01, 0x63, 0x63, 0x00, 0x64, 0x64, 0x0c, 0x63, 0x63,
0x00, 0x64, 0x64, 0x0c, 0x63, 0x63, 0x00, 0x64, 0x64, 0x0c, 0x63, 0x63, 0x00, 0x64, 0x64, 0x0c,
0x63, 0x64, 0x64, 0x04, 0x63, 0x64, 0x63, 0x63, 0x00, 0x64, 0x64, 0x03, 0x63, 0x64, 0x64, 0x03,
0x63, 0x63, 0x00, 0x64, 0x63, 0x63, 0x00, 0x64, 0x64, 0x03, 0x65, 0x63, 0x64, 0x64, 0x01, 0x63,
0x64, 0x64, 0x00, 0x65, 0x64, 0x64, 0x06, 0x63, 0x64, 0x64, 0x00, 0x63, 0x63, 0x00, 0x64, 0x64,
0x04, 0x64, 0x65, 0x65, 0x65, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x37, 0x37, 0x19, 0x36,
0x37, 0x37, 0x06, 0x37, 0x37, 0x37, 0x37, 0xff, 0xff, 0x90, 0xff, 0xff, 0xff, 0xff
};


static const uint8 orange_chroma_plane_decoding[] =
{
0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
};

static const uint8 green_chroma_plane_decoding[] =
{
0x37, 0x37, 0x19, 0x36, 0x37, 0x37, 0x06, 0x37, 0x37, 0x37, 0x37
};

static const uint8 alpha_chroma_plane_decoding[] =
{
0xff, 0xff, 0x90, 0xff, 0xff, 0xff, 0xff
};

static const uint8 final_decompressed_data[] =
{
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xff, 0x3f, 0x12, 0x00, 0xff, 0x3e, 0x11, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xff, 0x3e, 0x11, 0x00, 0xff, 0x3e, 0x11, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xff, 0x44, 0x0f, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xff, 0x44, 0x0f, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0x0d, 0xf0, 0xad, 0xba,
0xfe, 0x43, 0x0e, 0x00, 0xfd, 0x42, 0x0d, 0x00, 0xfe, 0x43, 0x0e, 0x00, 0xfe, 0x43, 0x0e, 0x00,
0xfd, 0x42, 0x0d, 0x00, 0xfd, 0x42, 0x0d, 0x00
};


void test_nsc_decompress(void)
{
	NSC_CONTEXT* context;
	STREAM* s;
	uint8* data = compressed_bitmap_data;
	uint32 length = sizeof(compressed_bitmap_data);
	int i;

	context = nsc_context_new();

	// FIXME not very unit test friendly, run thru nsc_process_message() by hand

	s = stream_new(0);
	stream_attach(s, data, length);

	context->width = 15;
	context->height = 10;

	nsc_context_initialize(context, s);

	CU_ASSERT(context->nsc_stream->PlaneByteCount[0] == 113);
	CU_ASSERT(context->nsc_stream->PlaneByteCount[1] == 7);
	CU_ASSERT(context->nsc_stream->PlaneByteCount[2] == 11);
	CU_ASSERT(context->nsc_stream->PlaneByteCount[3] == 7);

	CU_ASSERT(context->nsc_stream->colorLossLevel == 3);
	CU_ASSERT(context->nsc_stream->ChromaSubSamplingLevel == 1);

	CU_ASSERT(context->OrgByteCount[0] == 160);
	CU_ASSERT(context->OrgByteCount[1] == 40);
	CU_ASSERT(context->OrgByteCount[2] == 40);
	CU_ASSERT(context->OrgByteCount[3] == 150);

	nsc_rle_decompress_data(context);

#if 0
	// TODO, memcmp/check the decompressed buffers
	for (i = 0; i < 4; i++)
	{
		printf("---\n");
		freerdp_hexdump(context->org_buf[i]->data, context->org_buf[i]->size);
	}

#endif

	/* colorloss recover */
	nsc_cl_expand(context->org_buf[1], context->Co, context->nsc_stream->colorLossLevel, context->OrgByteCount[1]);
	nsc_cl_expand(context->org_buf[2], context->Cg, context->nsc_stream->colorLossLevel, context->OrgByteCount[2]);

	/* Chroma supersample */
	if(context->nsc_stream->ChromaSubSamplingLevel)
	{
		nsc_chroma_supersample(context, &context->Co, context->OrgByteCount[0]);
		nsc_chroma_supersample(context, &context->Cg, context->OrgByteCount[0]);
	}

	/* YCoCg to combined ARGB */
	nsc_ycocg_combined_argb(context);

	// printf("\n"); freerdp_hexdump(context->bmpdata, 600);

	CU_ASSERT_FATAL(memcmp(context->bmpdata, final_decompressed_data, sizeof(600)) == 0)

	nsc_context_destroy(context);
	nsc_context_free(context);
}


int init_nsc_suite(void)
{
	return 0;
}

int clean_nsc_suite(void)
{
	return 0;
}

int add_nsc_suite(void)
{
	add_test_suite(nsc);

	add_test_function(nsc_decompress);

	return 0;
}

